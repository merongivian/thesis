\section{Metodologías Ágiles}

En el software se tiene un amplio número de metodologías de desarrollo, las
primeras fueron inspiradas en metodologías usadas en otras ramas de ingeniería
y adaptadas para su uso en la construcción de sistemas informáticos. Estas
promueven un desarrollo lineal, haciendo énfasis en la planificación exhaustiva
para su posterior ejecución. Un ejemplo de estas metodologías es el desarrollo
en cascada.

Uno de los motivos por los cuales no se recomienda usar metodologías de
desarrollo lineales, como el desarrollo en cascada, es que son procesos muy
rígidos,  los cuales  contemplan, de antemano, que todos los proyectos de
software son similares y que no necesitan gestionar muchos cambios a lo largo
de su existencia.

Son contados los tipos de proyectos en el mundo del software que tienen una
base y aplicación parecidas, y al ser el desarrollo de sistemas una rama
relativamente joven en comparación a otras ingenierías, no se puede confiar
ciegamente en un proceso que considera la construcción de sistemas de software
como un proceso probado y casi infalible. Las metodologías ágiles nacieron con
el objetivo de solventar estas deficiencias y obtener un mejor tiempo de
respuesta a posibles errores o cambios que se den a lo largo de un proyecto,
por medio de iteraciones cortas para así obtener un mejor feedback por parte
del cliente.

\subsection{Manifiesto Ágil}

Como una alternativa a métodos formales, un grupo de desarrolladores decidió
reunirse para establecer una forma mucho mas flexible, adaptable y
acorde a las nuevas necesidades del desarrollo de software. Entre estos
se encontraba Kent beck, creador de la metodología Extreme Programming.
En esta reunión se estableció lo que hoy se conoce como el manifiesto
ágil, este consta de los siguientes principios:

\subsubsection{Valorar más a los individuos y su interacción que a los procesos y las herramientas}

En la industria generalmente se tiende a enaltecer los procesos como la única
manera de lograr un objetivo en conjunto, dejando de lado el factor humano.
Se debe considerar a los procesos como una ayuda mas no como la unica forma
de llevar adelante un proyecto

\subsubsection{Valorar más el software que funciona que la documentación exhaustiva}

La documentación siempre es importante, tanto como respaldo o como constancia
del trabajo realizado pero no es lo primero que ve el cliente. Un proyecto
en funcionamiento es prueba suficiente de lo realizado.

\subsubsection{Valorar más la colaboración con el cliente que la negociación contractual}

Las metodologías tradicionales tienden a sobreplanificar los proyectos de
desarrollo como una manera de acordar el trabajo a ser realizado con el cliente.
Esto generalmente termina en un producto erroneo y en estimaciones incorrectas
del trabajo a realizarse. Al tener una colaboración constante con el cliente
se obtiene un acuerdo instantáneo con el mismo.

\subsubsection{Valorar más la respuesta al cambio que el seguimiento de un plan}

Al igual que en una negociación contractual, regirse completamente a un
plan inicial aumenta el riesgo de no obtener el producto deseado. Se debe
considerar el tener un plan inicial pero se debe tomar en cuenta que
este puede cambiar a lo largo del desarrollo.

\subsection{Tipos}

\subsubsection{Scrum}

Scrum forma parte de las metodologías ágiles que consideran un proceso
iterativo e incremental de desarrollo. Un equipo de scrum es
autorganizado y altamente comunicativo. Las tareas se cumplen en sprints
que por lo general duran entre dos y cuatros semanas, cada sprint
contiene un backlog de estas tareas, las cuales son ordenadas de acuerdo
a su prioridad. El equipo entero es el encargado de estimar el
esfuerzo necesario para acabar cada una de las tareas.

\subsubsection{Extreme Programming}

Al igual que scrum, XP considera también un proceso iterativo pero este
hace mayor énfasis en el proceso de desarrollo de software. Sus principales
características son: Creación pruebas unitarias de tu código, programación
en parejas, re factorización constante del código y retroalimentación
constante de los cambios por parte del cliente.

\section{Desarrollo guiado por pruebas}

El desarrollo guiado por pruebas o TDD es una practica de software la
cual conlleva la creación de test automatizados. Estos tests son
creados y mantenidos por los desarrolladores. Entre los beneficios
del TDD están la mejora del codigo y una mayor tolerancia al cambio

\subsection{Red, Green, Refactor}

TDD considera un proceso estricto, el cual se debe
seguir, al pie de la letra, con el objetivo de pensar primero lo que queremos
implementar, para así tener una mejor idea de lo queremos desarrollar, y luego
ir mejorando nuestro código, a este proceso se lo denomina Red, Green, Refactor

\subsubsection{Red (prueba fallida)}

El Red se refiere a que debemos crear primero nuestra prueba y no realizar
ningún código. Al correr el test nuestra prueba debería estar en rojo, lo cual
significa que el test no ha pasado.

\subsubsection{Green (prueba superada)}

El siguiente paso es hacer pasar nuestra prueba creando el código
correspondiente, una vez que el test pase, al correr nuestra prueba esta dará
verde.

\subsubsection{Refactor (mejorar código)}

Una vez que hemos acabado de programar procedemos a mejorar nuestro código,
cada vez que realizamos un refactor debemos aseguramos de que nuestra prueba
siga pasando. Si nuestro test vuelve a dar error repetimos el ciclo.

\subsection{Errores comunes en el proceso de crear pruebas}

\subsubsection{Pensar en el porcentaje de cobertura de nuestras pruebas}
La cobertura de pruebas es el porcentaje de código que cubren nuestros test. La
situación ideal es tener una cobertura del 100%, pero esto nunca se logra ,
tanto por los cambios constantes que se realiza al código y por el hecho mismo
de que las personas escriban los tests. Las pruebas que se enfocan solo en la
cobertura tienden a crear código poco refactorizable y generan pruebas muy
frágiles y poco tolerantes a los cambios

\subsubsection{No fallar primero}

\subsubsection{No tomar un tiempo comparable para realizar refactor}
Idealmente se debe tomar el mismo tiempo tanto para tanto hacer refactoring
como para crear el test. Esto a la larga produce un código mas limpio y
mantenible

\subsection{Mocking}
Las pruebas deben crearse en base solo a la funcionalidad que vayan a
implementar , cualquier dependencia debe mantenerse al mínimo, tanto por
rendimiento del sistema como por diseño del código. Otro motivo para mantener
la dependencia al mínimo en tests es que no podemos probar una dependencia de
manera correcta , como por ejemplo llamadas a servicios web externos , estas
llamadas pueden cambiar constantemente y quebrar nuestros tests. Con el objetivo
de ocultar estas dependencias se crearon los mocks.  Un mock es un objeto
ficticio que reemplaza a un objeto real dentro de nuestro test

\subsubsection{Ventajas}
Nuestros tests corren mas rápido y no dependen uno de otro, lo cual permite
probar cada parte de manera aislada y con mayor facilidad

\subsubsection{Desventajas}
Crear muchos mocks puede llevar a la creación de pruebas no fiables, ya que
asumimos una salida en nuestro mock que puede cambiar en cualquier momento en
el objeto real

\subsection{Pruebas y su impacto en el desarrollo}

\subsubsection{Diseño del código}
El realizar las pruebas primero antes de escribir el código nos ayuda a
entender mejor nuestro código y su relación con otras partes de nuestro
sistema, esto genera una mejora drástica en el diseño. La forma en la que los
tests nos indican que pueden haber problemas de diseño es cuando el test se
vuelve muy difícil de implementar, lo cual nos indica que nuestro código tiene
muchas responsabilidades y parte de esas responsabilidades deben ser extraídas
y testeadas de manera mas profunda

\subsubsection{Documentación}
Las pruebas no solo nos ayuda a tener un código mas claro, lo cual en si ya
tiene un impacto en nuestro entendimiento del código, estas también sirven como
documentación, indicándonos cuales son los parámetros de entrada y cual es la
salida que obtendremos al correr un código especifico . Ciertas librerías de
pruebas nos permiten incluso escribir nuestros tests como si estuviéramos
escribiendo texto, dando lugar a pruebas claramente descritas.

\subsubsection{Debugging}
Uno de los objetivos de hacer pruebas es deshacernos
del proceso de debugging, si nos encontramos haciendo debugging significa que
no hemos realizado las suficientes pruebas a nuestro código y que este oculta
una responsabilidad que debe ser extraída, por lo cual se debe testear mas a
profundidad fuera del contexto de nuestro primer test

\section{Frameworks de desarrollo}
Un framework o marco de trabajo es una herramienta que permite crear
aplicaciones con mayor rapidez sin tener que empezar desde cero . Los marcos de
trabajo web incorporan conexiones a múltiples bases de datos, comunicación de
datos a la web, manejo de requests por parte de los navegadores y los presentan
de una forma sencilla para el programador. Esto lo logran siguiendo patrones de
diseño

\subsection{Modelo Vista Controlador}
MVC es un patrón de diseño que separa su lógico por medio de tres objetos:
modelo , vista y controlador , el modelo se encarga de la parte de persistencia
de datos, la vista de la parte gráfica y el controlador de lo referente a
manejo de requerimientos activados por la vista.

\subsubsection{Elementos MVC}

\paragraph{Modelo}
El modelo abstrae todo lo referente a conexión con bases
de datos por medio de un objeto, este objeto representa una tabla en nuestro
sistema. Cuando la clase modelo se hereda nos provee múltiples funcionalidades
como validaciones de datos, relaciones con otros objetos, y una interfaz clara
tanto como para guardar como para obtener datos de la base

\paragraph{Vista}
En lo referente a web la vista representa el html creado. Algunos frameworks
incorporan templates que nos permiten generar html usando código desde nuestro
backend

\paragraph{Controlador} Se encarga de manejar todos los requests
provenientes de la vista , en este caso un navegador será el que lo active. A
su vez redirecciona datos a las vistas correspondientes

\subsubsection{Proceso MVC}
El controlador es el eje principal dentro de un esquema mvc. El ruteador es el
encargado de recibir un url y redirigirlo al controlador correspondiente. En
caso de que se necesiten datos para desplegar la pagina, el controlador recurre
al modelo correspondiente, el cual llamara a la base. Una vez que el
controlador obtiene los datos los redirige a la vista y los despliega en el
navegador

\subsubsection{Ventajas}
Una de las principales bases de MVC y su mayor fortaleza es la separación
correcta de los roles y su flujo dentro de una aplicación, lo cual nos permite
pensar en el flujo de los datos a través de estas capas, sin tener que
preocuparnos por lo que pasa por debajo . Este concepto de mvc lleva ya
bastante tiempo , lo cual ha permitido la evolución de los frameworks que
adoptan este patrón a tal punto que ahora es muy fácil crear un aplicación
desde cero.

\subsubsection{Desventajas}
MVC fue pensado para aplicaciones de escritorio , las cuales generalmente
manejan un solo lenguaje de programación. En el caso de un ambiente web se
tiene el lenguaje usado tanto en el backend como en el front-end, esto da a
lugar a aplicaciones mucho mas complejas que requieren mucha mas programación
fuera del framework, para crear aplicaciones mas dinámicas en el front-end.
Para crear aplicaciones que no necesitan refresco en el navegador, por ejemplo,
se necesita una librería externa , con su propio patrón de diseño, el cual a su
vez tiene que relacionarse con en el framework mvc para obtener datos.

\subsection{Modelo Vista Vista-Modelo}
MVVM es un patrón generalmente usado en aplicaciones que requieren una
constante actualización de datos. Los datos del modelo no pasan por un
controlador, sino que son manejados por una capa intermedia llamada
vista-modelo, la cual sirve de contexto para la publicación de datos
en las vistas.

\subsubsection{Elementos MVVM}

\paragraph{Modelo}
Al igual que en el patrón MVC, este se encarga de la obtención y
validación de datos de manera transparente, independiente del
tipo o fuente de datos

\paragraph{Vista-Modelo}
Maneja la actualización de datos del modelo por medio de eventos. En esta capa
se asume que los datos se actualizan automáticamente, por lo cual no es
necesario definir métodos explícitos para manejar la creación o eliminación
de datos.

\paragraph{Vista}
Se encarga de mostrar los datos y ejecutar los eventos definidos en la
capa de Vista-Modelo. Los datos se actualizan automáticamente sin necesidad
de hacer refrescos de página

\subsubsection{Proceso MVVM}
En el momento en el que un usuario realiza una acción en la vista, esta ejecutara
una acción en la capa vista-modelo, esta a su vez se encargara de realizar las
consultas o cambios respectivos en el modelo. No existe necesidad de enviar los
datos de nuevo a las vistas ya que estas se actualizan de manera automática

\subsubsection{Ventajas}
Este tipo de framework nos ayuda a crear aplicaciones mucho mas ricas
que en uno de tipo MVC, las cuales debido a su interactividad pueden
ser transportadas fácilmente a otro tipo de interfaces, como los
dispositivos móviles.
Debido a que necesitan un refresco de datos constante, estos frameworks
contienen abstracciones que nos permiten manejar datos en tiempo real
de manera mucha mas fácil, sin necesidad de crear código adicional en
el lado del cliente.

\subsubsection{Desventajas}
El patrón MVVM asume que todas nuestras vistas deben estar constantemente
actualizadas, lo cual a la larga puede generar problemas desempeño. Estos
problemas generalmente son mas notorios en el lado del cliente, pero a también
pueden pasar al lado del servidor.
Por razones de seguridad, se puede requerir que los datos
pasen primero por un proceso de validación directamente en el servidor,
antes de que puedan ser mostrados en el cliente, esto no es posible en
estos tipo de frameworks ya que la mayor parte del procesamiento pasa
primero en el cliente.

\section{Edición Musical}

La edición musical conlleva el cambio y la manipulación de determinados
sonidos, pudiendo ser estos pregrabados o creados por medios analogicos
o digitales. Con el fin de suavizar el resultado final de una cancion o
melodia es necesario mezclar los sonidos de tal manera no se noten los
cambios abruptos en el sonido, pudiendo darse estos en la frecuencia o
la amplitud del sonido. Tambien se buscar realzar ciertas partes de una
melodia agregando efectos y combinarlos con cambios en la amplitud del sonido.
Gracias a los medios digitales el proceso de edicion se ha vuelto mucho
mas fácil y de mejor calidad

\subsection{Audio Digital}

Antes de existir las computadoras las grabaciones eran realizadas de
forma analogica, es decir se almacenaban en medios fisicos como cassettes
o vinilos.
Conseguir equipos de mezclo para medio analogicos era considerado costoso
y muy dificil de manejar. Ahora mediante las grabaciones digitales podemos
almacenar nuestras grabaciones en un archivo digital y procesarlo en
software de edicion de sonido. De igual forma podemos generar sonidos
digitales, sin la necesidad de contar con un instrumento podemos generar
sonidos y manipularlos directamente

\subsection{Sintetizadores Digitales}

Los sintetizadores digitales nacieron junto con la era del sonido digital,
estos crean sonidos por medio de la manipulacion digital de las ondas
y sus propiedades, estas ondas son generadas por medio de un oscilador

\subsubsection{Oscilador}

Es una señal que nos permite generar ondas y manipularlas para crear
sonidos

\paragraph{Manipulación de Onda}
\subparagraph{Distancia}

Especifica el tiempo que va a durar el sonido generado

\subparagraph{Frecuencia, longitud de Onda}

Es el numero de ciclos generado por la onda, este se traduce en una
nota musical, por ejemplo los 440Hz corresponden a la nota LA

\subparagraph{Amplitud}

Es el tamaño de la onda, este se traduce en el volumen del
sonido generado

\subparagraph{Tipos de Onda}

Las formas de onda transforman el sonido generado (cambiando su timbre),
existen los siguientes tipos de onda:

sine, square, triangle sawtooth

\subsection{Sequenciadores Musicales}

El secuenciador es un forma de edicion musical muy basica, el cual
nos permite generar sonidos y ordenarlos en un punto en el tiempo
para su reproduccion. Entre los primeros secuenciadores musicales
tenemos a la caja musical, el cual cuenta con dientes que reproducen
una determinada nota al momento de accionarlo. Dependiendo
de la velocidad del rodillo, la pista grabada en este se reproduce
mas rapido o mas lento. En la actualidad se cuenta con software
secuenciadores que nos permiten grabar y programar pistas

\subsubsection{Sequencer}

Un sequencer cuenta con varias pistas, cada pista contiene notas musicales
a las cuales se les puede modificar el volumen, anadir efectos y cambiar
su sonido modificando el tipo de onda. Posee tambien controles para su
reproducción y un piano para identificar las notas. Se puede usar
el teclado proporcionado en el software o podemos conectar un teclado
fisico por medio del protocolo MIDI

\subsubsection{Tracker}

El tracker en un tipo de sequencer el cual representa las notas por medio
de codigos, este codigo contiene datos como el volumen, la nota, el efecto
entre otros. Una cancion entera consta de una grilla, donde las filas
representan un punto en el tiempo y las columnas un canal especifico.
La edicion en un tracker es mucho mas compleja y menos amigable que
la de un sequencer normal, fueron creadas de esta forma debido a la
carencia en su tiempo de interfaces graficas mas ricas como las que
tenemos en la actualidad.

\section{Herramientas}

\subsection{Volt Framework}
\subsection{Web Audio Api}
\subsection{Transpiler}
